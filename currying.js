const multiply = (a, b) => a * b;

console.log(multiply(a, b));
// const multiply = (a, b) => a * b;

// console.log(multiply(2, 3));

// // карирование

// const mul = (x) => {
//   return (y) => {
//     return (z) => {
//       return x * y * z;
//     }
//   }
// }
// // Первые две с аргументами x и yведут себя как функции Accumulator и сохраняют значения в цепочке областей видимости внутренних функций или, как мы из называем в JavaScript, — замыканий.

// // ==============

// // cсоздадим две функции, которые мы хотим каррировать с тремя и четырью аргументами 


/*
{
const _sum3 = (x, y, z) => x + y + z;

const _sum4 = (p, q, r, s) => p + q + r + s;

// // создадим функцию curry с входным параметром функцией для каррирования
// //  находим арность функции (кол-во входных аргументов) через fn.length и сохраняем значение в N 

// // цель - вернуть внутреннюю ф-цию N раз. Т.е кол-во вызово каррированного sum равно кол-ву принимаемых аргументов
// // _sum(1, 2, 3, ..., N) => sum(1)(2)(3)...(N)

// // 
function curry(initialFunc) {
  const N = initialFunc.length
  function innerFn(n, args){  // innerFn, которая отслеживает переменную N и в зависимости от ее значения возвращает другую функцию, либо завершает процесс, вызывая текущую функцию со всеми накопленными аргументами. Поэтому ее и называют функцией Accumulator.
    return function acctualInnerFunction(a){
      // Внутри тела функции actualInnerFunction выполняется проверка и определяется, следует ли повторить итерацию заново или нужно остановить процесс. Это настоящая функция, которая последовательно вызывается пользователем как sum(1)(2)(3).
      if (n <= 1) {
        return initialFunc(...args, a)
      }
      return innerFn(n - 1, [...args, a])
      // При выполнении для n = 3 мы проверяем, не вызывается ли в данный момент последний аргумент. Если нет, то потребуется две итерации для возвращения actualInnerFn(3–1 = 2) раз.
    }
  }
  return innerFn(N, [])
}

//  базовый сценарий, при котором n = 1 указывает на то, что такая функция вызывается в последний раз. Получается, что внутри тела функции мы прописали сценарий завершения, задав условие и выполнив начальную функцию с накопленными аргументами в переменной args. Последний аргумент a передается в виде fn(...args, a).

const sum3 = curry(_sum3);
const sum4 = curry(_sum4);

console.log(sum3(1)(3)(2)); // 6
console.log(sum4(1)(3)(2)(4)); // 10

}
/*

// ====================